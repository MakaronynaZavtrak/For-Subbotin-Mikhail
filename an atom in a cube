#include <iostream>
#include "Vectors.h"

using namespace std;
int main()
{
	setlocale(LC_ALL, "RUS");
	std::cout << "Введите координаты начальной точки" << endl;
	double x, y, z;
	cin >> x >> y >> z;

	while (x < 0 || x > 1 || y < 0 || y > 1 || z < 0 || z > 1)
	{
		std::cout << "Ошибка! Точка находится вне куба! Попробуйте еще раз!" << endl;
		cin >> x >> y >> z;
	}

	Vectors point(x, y, z);

	std::cout << "Введите вектор скорости" << endl;
	double speedX, speedY, speedZ;
	cin >> speedX >> speedY >> speedZ;

	std::cout << "Введите время T большое" << endl;
	double T;
	cin >> T;

	if (!speedX && !speedY && !speedZ)
	{
		std::cout << "Положение куба в момент T:" << '(' << x << ", " << y << ", " << z << ')';
		return 0;
	}

	Vectors speed(speedX, speedY, speedZ);
	double currentTime = 0;
	Vectors newPosition;
	double t = 0;

	while (currentTime < T)
	{
		newPosition = add(point, speed);

		//в данном блоке ветвлений находится максимальное значене для переменной  t
		//она отвечает за время полёта атома за границей куба
		if (newPosition.x > 1)
			if ((newPosition.x - 1) / speed.x > t)
			{
				t = (newPosition.x - 1) / speed.x;
			}
		if (newPosition.x < 0)
			if (newPosition.x / speed.x > t)
			{
				t = newPosition.x / speed.x;
			}
		if (newPosition.y > 1)
			if ((newPosition.y - 1) / speed.y > t)
			{
				t = (newPosition.y - 1) / speed.y;
			}
		if (newPosition.y < 0)
			if (newPosition.y / speed.y > t)
			{
				t = newPosition.y / speed.y;
			}
		if (newPosition.z > 1)
			if ((newPosition.z - 1) / speed.z > t)
			{
				t = (newPosition.z - 1) / speed.z;
			}
		if (newPosition.z < 0)
			if (newPosition.z / speed.z > t)
			{
				t = newPosition.z / speed.z;
			}

		newPosition = sub(newPosition, mulByScalar(t, speed));

		//случай, если атом не долетел до границы куба в момент T
		if (currentTime + 1 - t >= T)
		{
			point = sub(newPosition, mulByScalar(currentTime + 1 - t - T, speed));
			break;
		}

		//проверка на соударения
		if (t > 0)
		{
			//случаи удара об угол
			if ((newPosition.x == 1 || !newPosition.x) && (newPosition.y == 1 || !newPosition.y) && (newPosition.z == 1 || !newPosition.z))
				speed = mulByScalar(-1, speed);

			//случаи удара об ребро куба	
			//рассматриваются 3 группы по 4 параллельных рёбер
			else if ((newPosition.x == 1 || !newPosition.x) && (newPosition.y == 1 || !newPosition.y) && newPosition.z > 0 && newPosition.z < 1)
				speed = Vectors(-speed.x, -speed.y, speed.z);
			else if (newPosition.x > 0 && newPosition.x < 1 && (newPosition.y == 1 || !newPosition.y) && (newPosition.z == 1 || !newPosition.z))
				speed = Vectors(speed.x, -speed.y, -speed.z);
			else if ((newPosition.x == 1 || !newPosition.x) && newPosition.y > 0 && newPosition.y < 1 && (newPosition.z == 1 || !newPosition.z))
				speed = Vectors(-speed.x, speed.y, -speed.z);

			//случаи удара об стенку
			else if (newPosition.x == 1 || !newPosition.x)
				speed.x *= -1;
			else if (newPosition.y == 1 || !newPosition.y)
				speed.y *= -1;
			else if (newPosition.z == 1 || !newPosition.z)
				speed.z *= -1;
		}

		currentTime += 1 - t;
		t = 0;
		point = newPosition;
	}

	std::cout << "Положение атома в момент T:" << '(' << point.x << ", " << point.y << ", " << point.z << ')';

	return 0;
}
